> 工作中经常写sql，也做过一些sql性能的优化，回顾自己工作经历，在做这些工作的时候虽然解决了问题，但是没有全面系统的思考，对于MySQL索引这方面也没有形成自己全面的理解；需要进行总结归纳，在工作中不断实践。
>
> 根据自己的实际情况和阅读MySQL官方文档，将对MySQL索引这块的理解进行整理

版本说明：5.7.34   

存储引擎：InnoDB

[InnoDB索引官方文档](https://dev.mysql.com/doc/refman/8.0/en/innodb-indexes.html)

> 不同版本之间会有区别，真是🐕

## 索引

> 索引是一个排好序的数据结构

## 索引结构

> 哈希 ， B+树
>
> 索引页的大小默认也是16KB

B+树除叶子节点外其他节点不存储数据，内存页中可以存放更多的key，IO次数减少

B+树叶子节点存储键和值，并且叶子节点是通过排序的，不需要进行回表查询，顺序遍历方便

B+树支持范围查询

* 哈希索引

  > 仅仅满足‘=’和‘in’

* B树

  > 1.叶子节点不是双向链表结构，对范围查找不太友好
  >
  > 2.非叶子节点存储数据，导致节点分叉减少，树深度增加，IO次数增加

## 主键自增和非自增区别

> 索引是一个排好序的数据结构，新增时一般顺序往后增加
>
> 如果是非自增主键，在增加索引时，如果某个节点数量达到限制，则会进行分裂，严重情况下造成索引树大量重新构建，影响性能

## 索引类型

* 从存储引擎分析

  > Innodb：聚簇索引
  >
  > * 聚簇索引：B+树叶子节点存储数据而不是主键
  >* 二级索引（辅助索引）：B+树叶子节点存储的是索引列和主键地址
  
* 类型：

  - 主键索引
  
    > 官方文档：如果没有指定主键，则使用唯一索引作为主键索引；如果没有唯一索引，则会自动生成一个隐藏的字段作为主键索引，大小6KB
  
  - 普通索引
  
  - 唯一索引
  
    > 更新操作时性能不高，需要进行IO，校验唯一性
  
  - 联合索引
  
  - 全文索引（Full Text）
  
  - 空间索引(待研究)

## explain

* Type

  * system ：表中只有一行数据
  * const：一般是主键索引或者唯一索引
  * eq_ref：唯一性索引扫描
  * ref：非唯一性索引扫描
  * range：范围查找
  * index：只查找索引即可获取数据，涉及索引覆盖
  * all：全表扫描
  * index merge 索引合并技术

* extra

  > **这块场景比较多，需要积累**

* rows

* possible_keys

  > 在查询语句中使用到的索引

## 索引区分度

>show index from table 查看索引区分度

索引区分度越大越好，通过此索引一次过滤掉的数据越多

## 索引长度

> MySQL对索引字段的长度是有限制的，具体限制根据版本而定
>
> **选择合适的索引长度可以占用更少的磁盘空间，内存空间和IO次数**

5.7以下索引长度最大为767bytes，5.7以后解除了限制，但最大长度不得超过3072bytes

> 为什么是3072与每页大小16k有关系，具体待研究

### 前缀索引

> 在创建索引时指定前缀，前缀最好保证值唯一，索引区分度尽可能的大
>
> **varchar字段上建立索引时，最好指定锁定长度**
>
> * 优势
>   * 节约磁盘空间，减少IO次数，提高查询效率
> * 劣势
>   * 无法使用索引覆盖
>   * 不能使用group by 和 order by

## 索引字段类型误区

> 创建索引：CREATE INDEX indexname on table (columnName(length))

* CHAR/VARCHAR

  > 创建索引时可以不指定索引的长度，默认整列为索引
  >
  > VARCHAR最大为255个字符

* TEXT/BLOG

  > 可以创建索引，但是在创建索引时必须指定前缀索引的长度，也就是子部分

## 索引合并-index merge

> 在mysql5.1版本之后出现了索引合并技术

> 当在where条件中同时使用多个索引条件，并且是范围查询，此时会出现索引合并
>
> **索引合并有可能产生死锁**

* 过程：

  > 索引合并技术就是对多个索引分别进行条件查询，然后再将查询到的结果进行合并

* index intersect merge

  > 对多个索引条件扫描的结果取交集的

* 个人理解

  > 索引合并出现的情况需要根据具体的sql进行分析验证，不可一概而论(网上说的不一定对)

## 索引失效

### or前后没有同时使用索引

> 当or左右查询字段只有一个是索引时，索引失效

### 违背最左前缀匹配

> 在联合索引中需要遵循最左法则
>
> 如果出现跳列，则跳列之后的索引失效

### like关键字使用前缀模糊

### 查询条件使用不等于!= 或 <>

### is null和is not null

> 网上不一定对，需亲自实践
>
> 当索引字段上null值占少数时，is not null不会走索引,is null走索引
>
> 当索引字段上null值占多数时，is null 会走索引，is not null不走索引

### 查询条件做运算时

### 查询条件使用函数时

> CHAR_LENGTH

### 查询条件类型不一致

> 当索引字段为字符串类型，查询条件为数值类型时，索引失效

### 范围查询右侧的列

> 与网上不一致，待考证

### Mysql认为全表扫描时更快时

## 索引碎片

https://www.cnblogs.com/kerrycode/p/10943122.html

https://www.cnblogs.com/woodytu/p/4513562.html

> 查看表的状态：SHOW TABLE STATUS LIKE 'tableName';
>
> 整列碎片：OPTIMIZE TABLE 'tableName' **谨慎使用**

**碎片与内存和磁盘以及段页式内存管理方式，数据操作有关，待研究**

## 索引优化

> 上面对索引的基本知识及原理进行了总结，先根据自己实际了解程度，将**索引优化**进行总结

* 从索引角度优化
* 索引覆盖减少回表
* 联合索引中将高频字段放在最左边
* 从索引碎片的角度优化
* 最好单表查询

## 个人理解

* 关于索引失效的情况需要根据mysql版本，数据量以及具体的sql进行分析

* 平时对自己的写的sql最好用explain去分析，养成习惯

* 关于的索引目前了解以上这些，后面再不断积累，更新

  
  
  







