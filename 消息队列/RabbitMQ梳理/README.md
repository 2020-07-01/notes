> 前段时间对mq进行改造，进行系统数据流通变更，现结合自己知识体系做一个总结
>
> 消息队列的三个核心优势： **解耦，异步，削峰**

**业务场景**

> 中心2.0数据变更->canal监听->MQ->中心sync-listener监听->中心3.0&&分省MQ->分省sync-listener监听mq->入库&&数据变更mq
>
> 中心和分省需同步的表相同

* 中心交换机和分省交换机：topic，同一套代码，不同的队列监听
* 数据变更交换机：fanout，数据变更之后通知给其他业务线

## 基础概念

### 数据流通

> 生产者->交换机->队列->消费者

### Exchange

> 交换机，根据规则将消息路由到指定的队列

* fanout

  >广播交换机，忽略rounting key的存在，将消息路由到绑定的所有队列中

* direct 

  >直连交换机，mq默认的交换机，完全根据rounting key路由消息，**精确匹配**
  >
  >mq默认的交换机为一个名称为空的交换机

* topic

  >主题交换机，根据rounting key路由消息，rounting key支持模糊匹配

* headers

  >待实践

### Queue

#### arguments

* x-dead-letter-exchange:配置死信交换机

* x-dead-letter-routing-key:配置死信路由key

* x-expires:配置队列自动删除时间，指定时间段内没有访问则自动删除

* x-message-ttl:配置队列中消息的存活时间

* x-max-length:[配置队列中消息数量的最大值](https://rabbitmq.com/maxlength.html) 

* x-max-length-bytes:[队列中消息的最大容量](https://rabbitmq.com/maxlength.html)

  > 当队列中的消息容量达到最大值时，将从队列头开始删除

* x-single-active-consumer:设置每次只有一个消费者从队列中进行消费

* x-queue-mode:设置队列模式

  > default:队列会存储在内容中，更快的发送给消费者，性能更好
  >
  > lazy:队列中消息尽可能的存储在磁盘中，当消费时加载到内存中

* x-overflow:配置队列溢出行为

  > reject-publish或reject-publish-dlx:最近发布的消息将会丢弃

 ### channel

> 发布消息，接受消息，订阅消息等动作都是在**信道**中完成的
>
> TCP的创建和销毁开销特别大，需要经过3次握手和四次挥手，如果不使用信道，则应用程序会以TCP连接的方式连接RabbitMQ，高峰时刻则会造成资源的浪费，并且会有性能瓶颈

### 虚拟主机

> RabbitMQ可创建多个虚拟主机，每个虚拟主机相当于一个小的RabbitMQ服务器，拥有自己的交换机，队列和绑定关系等，各个虚拟主机之间互不冲突

## 消费者幂等消费(不被重复消费)

> 消费端可能造成数据重复消费，先说说哪些哪些情况可能造成数据重复消费

数据重复场景：

* 当生产者未收到ack确认消息，或者消息发送失败时，可能出现重复发送消息的情况，消费端需要对消息进行幂等处理

从以下几个方面进行处理：

* 对消息设置全局唯一ID，消费端通过Redis来进行去重
* 在对数据库进行操作之前，先根据主键等查询，在判断需要insert还是update
* 如果消费端写Redis，set命令天然幂等性
* 基于数据库唯一键做幂等处理

**幂等消费主要在消费端进行处理，要结合具体业务指定合适的方案**

## 消息的可靠性传输

> 消息在传输过程中可能造成数据丢失，先通过分析消息在哪些场景中可能造成丢失，在只当解决方案

* 消息丢失

  * 消息在传过程中丢失

    > 1.开启事务 不建议
    >
    > 2.消息发送失败回调

  * MQ挂掉了，内存中的消息丢失

    > 发送笑死时设置消息的deliveryMode未持久化模式
    >
    > 开启MQ交换机和队列的持久化，MQ重启之后会自动加载磁盘中的数据到内存中
    >
    > 特殊情况：内存中的数据还未进行持久化，MQ挂掉了，无法恢复

  * 消费者拿到消息后未来得及处理，消费者挂掉了

    > 开启手动acl模式，消费端确认消费完数据之后，MQ再删除消息

## 消息可靠性发送

> 消息的可靠性发送及可靠性传输有相同之处，不过侧重点不同

* 入库打标记

  ![可靠性投递方案](../静态资源/可靠性投递方案1.png)





* 延迟投递

![延迟投递](../静态资源/延迟投递.png)

>如果消费失败，则MSG DB中没有延迟消息，则通知上游重发
>
>可设置重试次数，人工补偿



## 可靠性传输

> 消息从生产者传输到消费者过程中可能存在丢失的情况，具体根据丢失的场景做合理处理

* exchange 和 queue 持久化
* rabbitmq事务
* 发送方确认
* 重试机制

## 消费端性能提升

* 单个消费者

  > 单个消费者连接队列，收到消息后将消息放到不同的线程中进行处理(公司业务实际运用)，这样会有多个线程处理消息，增加消费者的吞吐量，提升消费速度

* 增加消费者

## 消息有序性

> 每张表对应一个队列，每个队列对应一个消费者

## 消息堵塞处理

> 消息堵塞处理分为前置处理和后置处理，高可用环境下推荐前置处理和后置处理配合使用

* 前置处理
  > 场景分析：半夜消息队列堵塞，消费端来不及处理，生产端还在不断生产消息，此时消息队列可能被撑爆
  >
  > 解决方案：可在生产端添加**限流**，当队列中未消费的消息达到一定数量后，生产者可先将消息入库，当队列中的消息减少到一定数量时，继续将消息发到队列中

* 后置处理

  > 场景分析：消费端出现问题，导致消费消费速度慢，队列中消息挤压
  >
  > 解决方案：修复消费端问题，新建Topic交换机，将队列中消费分发到多个队列中，然后消费各队列中的消息，消费完毕之后再启动原先消费者

## 消息过期失效

当消费端消费慢，队列中消息阻塞，当消息挤压超过一定时间会被MQ清掉，可通过设置死信队列，方式消息丢失

## 集群模式-高可用

### 单机模式

> 单节点MQ，学习写demo用

### 普通集群模式

图省略......



### 镜像队列模式

图省略......


参考文章：

https://www.huaweicloud.com/articles/6a2d97cb2cb620b934187ff2670b62f5.html

