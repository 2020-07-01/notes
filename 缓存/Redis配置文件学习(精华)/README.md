> 通过通读Redis的配置文件，以及自己在工作中的实际应用，对Redis部分知识进行总结

## Redis 持久化方式 

> RDB是fork子进程生成新的数据快照
>
> AOF先执行命令，再将命令写回磁盘
>
> AOF优先于RDB

* 是否需要持久化

  > 如果Redis仅仅是用来做缓存，则可不需要进行持久化操作，可关闭RDB/AOF
  >
  > persistence-available [(yes)|no] 
  >
  > > no:关闭持久化
  > >
  > > yes:开启持久化

* RDB

  * 优点：

    > 1.fork子进程完成数据持久化工作，性能高
    >
    > 2.RDB文件小，适合大规模数据恢复

  * 缺点

    > 1.RDB是通过时间间隔内快照的方式将数据保存到磁盘上，会存在数据丢失的情况

* AOF

  - 优点：

    > 1.通过追加命令的方式进行持久化，数据完整性比较高

  - 缺点：

    > 1.数据文件大，恢复数据比较困难
    >
    > 2.可能会造成主线程阻塞或者数据丢失问题

## 数据持久化AOF

> **AOF方式是当命令执行完写入操作后将命令追加到文件系统的缓冲区**
>
> 再由操作系统将命令刷新到磁盘中，此处涉及**写回策略**

* 写回策略

  > **操作系统将文件缓存区的数据刷回磁盘的过程**

* 写回策略配置

  > Redis支持三种不同的写回模式
  >
  > * no：不做fsync磁盘同步，让操作系统决定刷新时间 （效率最快）
  > * always：每次写入追加日志后刷新到磁盘
  > * everysec：每秒同步一次刷新到磁盘  （最安全）

* 重写过程

  > AOF持久化方式会生成一个aof文件，这个文件大小达到一定程度时会触发**重写rewrite**，主线程会fork一个子线程来完成重写过程
  >
  > 客户端触发重写命令：bgrewriteaof
  >
  > 重写过程：对aof文件进行压缩

* **fsync阻塞**

  > 主线程进行fsync和子线程进行bgrewriteaof同时进行时，由于重写过程数据量大会导致主进程fsync阻塞
  >
  > 个人理解：fsync不是主线程完成的，但这是一个同步过程
  >
  > * no-appendfsync-on-rewrite
  >
  >   > no：不会丢失数据，但是会阻塞(最安全的方式)
  >   >
  >   > yes：主线程仅仅追加数据到缓冲区即可，没有主动同步过程，存在丢失数据风险
  >
  > * auto-aof-rewrite-min-size
  >
  >   > aof文件最小大小，aof文件重写触发条件
  >
  > * auto-aof-rewrite-percentage
  >
  >   > 重写百分比(待研究)

#### AOF个人理解

> 从个人理解总结一下AOF
>
> 1. 主线程执行写客户端命令
> 2. 主线程将客户端命令追加到文件缓存区
> 3. 等待执行fsync操作（这是一个同步过程，可设置）
> 4. 磁盘中的aof文件过大时触发**rewrite重写操作**
> 5. fsync和rewrite操作同时发生时会操作主线程阻塞
> 6. 根据业务场景通过参数折中设置

## 数据持久化-RDB

> RDB方式是生成数据快照
>
> 当Redis进行写入一条数据之后，会fork一个子进程来生成数据快照，生成rdb文件，fork操作是阻塞的

* 自动触发

  通过下面配置可进行自动触发bgsave

  > save 900 1
  > save 300 10
  > save 60 10000
  >
  > save "" : 表示停用RDB

* 手动触发

  > 通过bgsave/save命令可手动触发RDB
  >
  > bgsave是非阻塞得
  >
  > save是阻塞

* stop-writes-on-bgsave-error yes

  > 当Redis的RDB操作即bgsave异常时，则Redis不再接受写入操作，直到重启恢复

## 持久化总结

> aof和rdb两种备份方式都有自己的优缺点，可通过搭配使用的方式使性能与安全达到最高
>
> 此处也要结合主从节点(待研究)

## 内存淘汰策略

Redis之所以性能高，是因为Redis是一种内存数据库，数据会被加载到内存中，但是内存的容量是有限的，Redis需要通过一些策略来清理掉内存中不常用的数据。

> 当内存满时，如果再进行添加操作，会触发内存淘汰策略；
>
> 查询操作不受影响
>
> **配置文件中有6种淘汰策略**
>
> maxmemory-policy noeviction # 设置内存淘汰策略
>
>  maxmemory <bytes> # 设置内存大小

* 内存淘汰策略
  - noeviction 不做处理，返回错误信息
  - allkeys-random 在所有key中随机删除一个数据
  - volatile-random 在所有设置了过期时间的key中随机删除一个数据
  - volatile-ttl 在所有设置了过期时间的key中移除马上过期的key
  - volatile-lru  在所有设置了过期时间的key中移除最近最少使用的key
  - allkeys-lru 在所有key中移除最近最少使用的key

* 上面LRU和TTL不是精确的算法，默认检查5个key，选取最合适的删除，可进行配置

  > maxmemory-samples 5



